{
    "sourceFile": "lib/services/database_helper.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1728144840341,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1728145576920,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,9 +1,11 @@\n-import 'package:sqflite/sqflite.dart';\r\n+import 'package:sqflite_common/sqflite.dart';\r\n+import 'package:sqflite_common_ffi/sqflite_ffi.dart';\r\n import 'package:path/path.dart';\r\n import '../models/folder.dart';\r\n import '../models/book.dart';\r\n \r\n+\r\n class DatabaseHelper {\r\n   static final DatabaseHelper instance = DatabaseHelper._init();\r\n   static Database? _database;\r\n \r\n@@ -15,12 +17,21 @@\n     return _database!;\r\n   }\r\n \r\n   Future<Database> _initDB(String filePath) async {\r\n+    // Initialize FFI\r\n+    sqfliteFfiInit();\r\n+    // Change the default factory\r\n+    databaseFactory = databaseFactoryFfi;\r\n+\r\n     final dbPath = await getDatabasesPath();\r\n     final path = join(dbPath, filePath);\r\n \r\n-    return await openDatabase(path, version: 1, onCreate: _createDB);\r\n+    return await databaseFactory.openDatabase(path,\r\n+        options: OpenDatabaseOptions(\r\n+          version: 1,\r\n+          onCreate: _createDB,\r\n+        ));\r\n   }\r\n \r\n   Future<void> _createDB(Database db, int version) async {\r\n     await db.execute('''\r\n"
                },
                {
                    "date": 1728166553175,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,20 +17,19 @@\n     return _database!;\r\n   }\r\n \r\n   Future<Database> _initDB(String filePath) async {\r\n-    // Initialize FFI\r\n     sqfliteFfiInit();\r\n-    // Change the default factory\r\n     databaseFactory = databaseFactoryFfi;\r\n \r\n     final dbPath = await getDatabasesPath();\r\n     final path = join(dbPath, filePath);\r\n \r\n     return await databaseFactory.openDatabase(path,\r\n         options: OpenDatabaseOptions(\r\n-          version: 1,\r\n+          version: 2, // Increment the version number\r\n           onCreate: _createDB,\r\n+          onUpgrade: _upgradeDB,\r\n         ));\r\n   }\r\n \r\n   Future<void> _createDB(Database db, int version) async {\r\n@@ -63,10 +62,34 @@\n       PRIMARY KEY (bookId, tag),\r\n       FOREIGN KEY (bookId) REFERENCES books (id) ON DELETE CASCADE\r\n     )\r\n     ''');\r\n+\r\n+    await db.execute('''\r\n+    CREATE TABLE bookmarks(\r\n+      id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n+      bookId TEXT,\r\n+      pageNumber INTEGER,\r\n+      description TEXT,\r\n+      FOREIGN KEY (bookId) REFERENCES books (id) ON DELETE CASCADE\r\n+    )\r\n+    ''');\r\n   }\r\n \r\n+  Future<void> _upgradeDB(Database db, int oldVersion, int newVersion) async {\r\n+    if (oldVersion < 2) {\r\n+      await db.execute('''\r\n+      CREATE TABLE bookmarks(\r\n+        id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n+        bookId TEXT,\r\n+        pageNumber INTEGER,\r\n+        description TEXT,\r\n+        FOREIGN KEY (bookId) REFERENCES books (id) ON DELETE CASCADE\r\n+      )\r\n+      ''');\r\n+    }\r\n+  }\r\n+\r\n   Future<void> insertFolder(Folder folder) async {\r\n     final db = await database;\r\n     await db.insert('folders', {\r\n       'id': folder.id,\r\n@@ -86,14 +109,8 @@\n       where: 'id = ?',\r\n       whereArgs: [folder.id],\r\n     );\r\n   }\r\n-\r\n-  Future<void> deleteFolder(String folderId) async {\r\n-    final db = await database;\r\n-    await db.delete('folders', where: 'id = ?', whereArgs: [folderId]);\r\n-  }\r\n-\r\n   Future<void> insertBook(Book book, String folderId) async {\r\n     final db = await database;\r\n     await db.insert('books', {\r\n       'id': book.id,\r\n@@ -111,11 +128,19 @@\n         'bookId': book.id,\r\n         'tag': tag,\r\n       });\r\n     }\r\n+\r\n+    for (final bookmark in book.bookmarks) {\r\n+      await db.insert('bookmarks', {\r\n+        'bookId': book.id,\r\n+        'pageNumber': bookmark.pageNumber,\r\n+        'description': bookmark.description,\r\n+      });\r\n+    }\r\n   }\r\n \r\n-  Future<void> updateBook(Book book, String folderId) async {\r\n+  Future<void> updateBook(Book book) async {\r\n     final db = await database;\r\n     await db.update(\r\n       'books',\r\n       {\r\n@@ -123,9 +148,8 @@\n         'author': book.author,\r\n         'filePath': book.filePath,\r\n         'coverImagePath': book.coverImagePath,\r\n         'lastPageRead': book.lastPageRead,\r\n-        'folderId': folderId,\r\n       },\r\n       where: 'id = ?',\r\n       whereArgs: [book.id],\r\n     );\r\n@@ -136,25 +160,49 @@\n         'bookId': book.id,\r\n         'tag': tag,\r\n       });\r\n     }\r\n+\r\n+    await db.delete('bookmarks', where: 'bookId = ?', whereArgs: [book.id]);\r\n+    for (final bookmark in book.bookmarks) {\r\n+      await db.insert('bookmarks', {\r\n+        'bookId': book.id,\r\n+        'pageNumber': bookmark.pageNumber,\r\n+        'description': bookmark.description,\r\n+      });\r\n+    }\r\n   }\r\n \r\n+  Future<void> updateLastPageRead(Book book) async {\r\n+    final db = await database;\r\n+    await db.update(\r\n+      'books',\r\n+      {'lastPageRead': book.lastPageRead},\r\n+      where: 'id = ?',\r\n+      whereArgs: [book.id],\r\n+    );\r\n+  }\r\n+\r\n+  Future<void> updateBookFolder(Book book, String folderId) async {\r\n+    final db = await database;\r\n+    await db.update(\r\n+      'books',\r\n+      {'folderId': folderId},\r\n+      where: 'id = ?',\r\n+      whereArgs: [book.id],\r\n+    );\r\n+  }\r\n+\r\n   Future<void> deleteBook(String bookId) async {\r\n     final db = await database;\r\n     await db.delete('books', where: 'id = ?', whereArgs: [bookId]);\r\n   }\r\n \r\n-  Future<List<Folder>> getFolders() async {\r\n+\r\n+\r\n+  Future<void> deleteFolder(String folderId) async {\r\n     final db = await database;\r\n-    final List<Map<String, dynamic>> maps = await db.query('folders');\r\n-\r\n-    return List.generate(maps.length, (i) {\r\n-      return Folder(\r\n-        id: maps[i]['id'],\r\n-        name: maps[i]['name'],\r\n-      );\r\n-    });\r\n+    await db.delete('folders', where: 'id = ?', whereArgs: [folderId]);\r\n   }\r\n \r\n   Future<List<Book>> getBooksInFolder(String folderId) async {\r\n     final db = await database;\r\n@@ -172,8 +220,21 @@\n       );\r\n \r\n       final List<String> tags = tagMaps.map((tagMap) => tagMap['tag'] as String).toList();\r\n \r\n+      final List<Map<String, dynamic>> bookmarkMaps = await db.query(\r\n+        'bookmarks',\r\n+        where: 'bookId = ?',\r\n+        whereArgs: [map['id']],\r\n+      );\r\n+\r\n+      final List<BookmarkEntry> bookmarks = bookmarkMaps\r\n+          .map((bookmarkMap) => BookmarkEntry(\r\n+                pageNumber: bookmarkMap['pageNumber'] as int,\r\n+                description: bookmarkMap['description'] as String,\r\n+              ))\r\n+          .toList();\r\n+\r\n       return Book(\r\n         id: map['id'],\r\n         title: map['title'],\r\n         author: map['author'],\r\n@@ -181,8 +242,9 @@\n         coverImagePath: map['coverImagePath'],\r\n         lastPageRead: map['lastPageRead'],\r\n         dateAdded: DateTime.parse(map['dateAdded']),\r\n         tags: tags,\r\n+        bookmarks: bookmarks,\r\n       );\r\n     }).toList());\r\n   }\r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1728166919393,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -196,10 +196,35 @@\n     final db = await database;\r\n     await db.delete('books', where: 'id = ?', whereArgs: [bookId]);\r\n   }\r\n \r\n+  Future<List<Folder>> getFolders() async {\r\n+    final db = await database;\r\n+    final List<Map<String, dynamic>> maps = await db.query('folders');\r\n \r\n+    return Future.wait(maps.map((map) async {\r\n+      final List<Map<String, dynamic>> subfolderMaps = await db.query(\r\n+        'folders',\r\n+        where: 'parentId = ?',\r\n+        whereArgs: [map['id']],\r\n+      );\r\n \r\n+      final List<Folder> subfolders = subfolderMaps\r\n+          .map((subfolderMap) => Folder(\r\n+                id: subfolderMap['id'],\r\n+                name: subfolderMap['name'],\r\n+              ))\r\n+          .toList();\r\n+\r\n+      return Folder(\r\n+        id: map['id'],\r\n+        name: map['name'],\r\n+        subfolders: subfolders,\r\n+      );\r\n+    }).toList());\r\n+  }\r\n+\r\n+\r\n   Future<void> deleteFolder(String folderId) async {\r\n     final db = await database;\r\n     await db.delete('folders', where: 'id = ?', whereArgs: [folderId]);\r\n   }\r\n"
                }
            ],
            "date": 1728144840341,
            "name": "Commit-0",
            "content": "import 'package:sqflite/sqflite.dart';\r\nimport 'package:path/path.dart';\r\nimport '../models/folder.dart';\r\nimport '../models/book.dart';\r\n\r\nclass DatabaseHelper {\r\n  static final DatabaseHelper instance = DatabaseHelper._init();\r\n  static Database? _database;\r\n\r\n  DatabaseHelper._init();\r\n\r\n  Future<Database> get database async {\r\n    if (_database != null) return _database!;\r\n    _database = await _initDB('book_library.db');\r\n    return _database!;\r\n  }\r\n\r\n  Future<Database> _initDB(String filePath) async {\r\n    final dbPath = await getDatabasesPath();\r\n    final path = join(dbPath, filePath);\r\n\r\n    return await openDatabase(path, version: 1, onCreate: _createDB);\r\n  }\r\n\r\n  Future<void> _createDB(Database db, int version) async {\r\n    await db.execute('''\r\n    CREATE TABLE folders(\r\n      id TEXT PRIMARY KEY,\r\n      name TEXT,\r\n      parentId TEXT\r\n    )\r\n    ''');\r\n\r\n    await db.execute('''\r\n    CREATE TABLE books(\r\n      id TEXT PRIMARY KEY,\r\n      title TEXT,\r\n      author TEXT,\r\n      filePath TEXT,\r\n      coverImagePath TEXT,\r\n      lastPageRead INTEGER,\r\n      dateAdded TEXT,\r\n      folderId TEXT,\r\n      FOREIGN KEY (folderId) REFERENCES folders (id) ON DELETE CASCADE\r\n    )\r\n    ''');\r\n\r\n    await db.execute('''\r\n    CREATE TABLE book_tags(\r\n      bookId TEXT,\r\n      tag TEXT,\r\n      PRIMARY KEY (bookId, tag),\r\n      FOREIGN KEY (bookId) REFERENCES books (id) ON DELETE CASCADE\r\n    )\r\n    ''');\r\n  }\r\n\r\n  Future<void> insertFolder(Folder folder) async {\r\n    final db = await database;\r\n    await db.insert('folders', {\r\n      'id': folder.id,\r\n      'name': folder.name,\r\n      'parentId': folder.parent?.id,\r\n    });\r\n  }\r\n\r\n  Future<void> updateFolder(Folder folder) async {\r\n    final db = await database;\r\n    await db.update(\r\n      'folders',\r\n      {\r\n        'name': folder.name,\r\n        'parentId': folder.parent?.id,\r\n      },\r\n      where: 'id = ?',\r\n      whereArgs: [folder.id],\r\n    );\r\n  }\r\n\r\n  Future<void> deleteFolder(String folderId) async {\r\n    final db = await database;\r\n    await db.delete('folders', where: 'id = ?', whereArgs: [folderId]);\r\n  }\r\n\r\n  Future<void> insertBook(Book book, String folderId) async {\r\n    final db = await database;\r\n    await db.insert('books', {\r\n      'id': book.id,\r\n      'title': book.title,\r\n      'author': book.author,\r\n      'filePath': book.filePath,\r\n      'coverImagePath': book.coverImagePath,\r\n      'lastPageRead': book.lastPageRead,\r\n      'dateAdded': book.dateAdded.toIso8601String(),\r\n      'folderId': folderId,\r\n    });\r\n\r\n    for (final tag in book.tags) {\r\n      await db.insert('book_tags', {\r\n        'bookId': book.id,\r\n        'tag': tag,\r\n      });\r\n    }\r\n  }\r\n\r\n  Future<void> updateBook(Book book, String folderId) async {\r\n    final db = await database;\r\n    await db.update(\r\n      'books',\r\n      {\r\n        'title': book.title,\r\n        'author': book.author,\r\n        'filePath': book.filePath,\r\n        'coverImagePath': book.coverImagePath,\r\n        'lastPageRead': book.lastPageRead,\r\n        'folderId': folderId,\r\n      },\r\n      where: 'id = ?',\r\n      whereArgs: [book.id],\r\n    );\r\n\r\n    await db.delete('book_tags', where: 'bookId = ?', whereArgs: [book.id]);\r\n    for (final tag in book.tags) {\r\n      await db.insert('book_tags', {\r\n        'bookId': book.id,\r\n        'tag': tag,\r\n      });\r\n    }\r\n  }\r\n\r\n  Future<void> deleteBook(String bookId) async {\r\n    final db = await database;\r\n    await db.delete('books', where: 'id = ?', whereArgs: [bookId]);\r\n  }\r\n\r\n  Future<List<Folder>> getFolders() async {\r\n    final db = await database;\r\n    final List<Map<String, dynamic>> maps = await db.query('folders');\r\n\r\n    return List.generate(maps.length, (i) {\r\n      return Folder(\r\n        id: maps[i]['id'],\r\n        name: maps[i]['name'],\r\n      );\r\n    });\r\n  }\r\n\r\n  Future<List<Book>> getBooksInFolder(String folderId) async {\r\n    final db = await database;\r\n    final List<Map<String, dynamic>> maps = await db.query(\r\n      'books',\r\n      where: 'folderId = ?',\r\n      whereArgs: [folderId],\r\n    );\r\n\r\n    return Future.wait(maps.map((map) async {\r\n      final List<Map<String, dynamic>> tagMaps = await db.query(\r\n        'book_tags',\r\n        where: 'bookId = ?',\r\n        whereArgs: [map['id']],\r\n      );\r\n\r\n      final List<String> tags = tagMaps.map((tagMap) => tagMap['tag'] as String).toList();\r\n\r\n      return Book(\r\n        id: map['id'],\r\n        title: map['title'],\r\n        author: map['author'],\r\n        filePath: map['filePath'],\r\n        coverImagePath: map['coverImagePath'],\r\n        lastPageRead: map['lastPageRead'],\r\n        dateAdded: DateTime.parse(map['dateAdded']),\r\n        tags: tags,\r\n      );\r\n    }).toList());\r\n  }\r\n}"
        }
    ]
}